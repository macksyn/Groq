// plugins/mcm.js - Man Crush Monday Plugin (Unified Database)
import { getDatabase, safeOperation, unifiedUserManager } from '../lib/pluginIntegration.js';
import moment from 'moment-timezone';
import cron from 'node-cron';

// Plugin information export
export const info = {
  name: 'Man Crush Monday (MCM)',
  version: '1.3.0', // Version updated for unified DB
  author: 'Alex Macksyn (Adapted)',
  description: 'Weekly Man Crush Monday contest where guys post pictures and ladies rate them from 1-10. Now with unified database and economy.',
  commands: [
    {
      name: 'mcm',
      aliases: ['mancrush'],
      description: 'Access MCM system commands and settings'
    },
    {
      name: 'mcmstats',
      aliases: ['mcmhistory'],
      description: 'View MCM statistics and history'
    },
    {
      name: 'mcmtest',
      aliases: ['testmcm'],
      description: 'Test MCM rating validation'
    }
  ]
};

// MongoDB Configuration
const COLLECTIONS = {
  MCM_RECORDS: 'mcm_records',
  MCM_SETTINGS: 'mcm_settings',
  MCM_SESSIONS: 'mcm_sessions',
  MCM_PARTICIPANTS: 'mcm_participants',
  MCM_RATINGS: 'mcm_ratings'
};

// Set Nigeria timezone
moment.tz.setDefault('Africa/Lagos');

// Default MCM settings
const defaultSettings = {
  startTime: '20:00', // 8 PM
  endTime: '22:00',   // 10 PM
  winnerReward: 12000, // ‚Ç¶12,000 for winner
  participationReward: 1000, // ‚Ç¶1,000 for participation
  enableParticipationReward: true,
  reminderTimes: ['10:00', '16:00'], // Two reminders
  autoStartEnabled: true,
  adminNumbers: [],
  groupJids: [],
  tagAllMembers: false, // Changed to false to avoid spam
  maxPhotosPerUser: 1,
  validRatingRange: { min: 1, max: 10 },
  allowSelfRating: false
};

let mcmSettings = { ...defaultSettings };

// Cron jobs storage
let cronJobs = {
  reminders: [],
  startSession: null,
  endSession: null
};

// Initialize settings
async function loadSettings() {
  try {
    const settings = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SETTINGS).findOne({ type: 'mcm_config' })
    );
    if (settings) {
      mcmSettings = { ...defaultSettings, ...settings.data };
    }
  } catch (error) {
    console.error('Error loading MCM settings:', error);
  }
}

async function saveSettings() {
  try {
    await safeOperation(async (db) => {
      await db.collection(COLLECTIONS.MCM_SETTINGS).replaceOne(
        { type: 'mcm_config' },
        { type: 'mcm_config', data: mcmSettings, updatedAt: new Date() },
        { upsert: true }
      );
    });
  } catch (error) {
    console.error('Error saving MCM settings:', error);
  }
}

function getNigeriaTime() {
  return moment.tz('Africa/Lagos');
}

function getCurrentDate() {
  return getNigeriaTime().format('YYYY-MM-DD'); // Fixed to ISO format
}

function isMonday() {
  return getNigeriaTime().day() === 1; // 1 = Monday
}

async function getGroupMembers(sock, groupJid) {
  try {
    const groupMetadata = await sock.groupMetadata(groupJid);
    return groupMetadata.participants.map(participant => ({
      id: participant.id,
      admin: participant.admin || null
    }));
  } catch (error) {
    console.error('Error getting group members:', error);
    return [];
  }
}

async function isAuthorized(sock, from, sender) {
  if (mcmSettings.adminNumbers.includes(sender.split('@')[0])) return true;
  const ownerNumber = process.env.OWNER_NUMBER || '';
  if (sender.split('@')[0] === ownerNumber) return true;
  
  try {
    if (!from.endsWith('@g.us')) return false;
    const groupMetadata = await sock.groupMetadata(from);
    const groupAdmins = groupMetadata.participants
      .filter(p => p.admin === 'admin' || p.admin === 'superadmin')
      .map(p => p.id);
    return groupAdmins.includes(sender);
  } catch (error) {
    return false;
  }
}

// =======================================================================
// MCM SESSION MANAGEMENT
// =======================================================================

async function createMCMSession(groupJid) {
  try {
    const today = getCurrentDate();
    const sessionId = `mcm_${today}_${groupJid}`;
    
    const existingSession = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).findOne({ date: today, groupJid })
    );
    
    if (existingSession) {
      console.log(`MCM session already exists for ${today}`);
      return existingSession;
    }
    
    const sessionData = {
      sessionId,
      date: today,
      groupJid,
      status: 'active', // active, ended, cancelled
      startedAt: new Date(),
      endedAt: null,
      participants: [],
      totalRatings: 0,
      winnerDeclared: false,
      createdAt: new Date()
    };
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).insertOne(sessionData)
    );
    console.log(`‚úÖ MCM session created for ${today}`);
    return sessionData;
  } catch (error) {
    console.error('Error creating MCM session:', error);
    throw error;
  }
}

async function getCurrentSession(groupJid) {
  try {
    const today = getCurrentDate();
    return await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).findOne({ date: today, groupJid, status: 'active' })
    );
  } catch (error) {
    console.error('Error getting current session:', error);
    return null;
  }
}

async function cancelMCMSession(groupJid) {
  try {
    const session = await getCurrentSession(groupJid);
    if (!session) return false;
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).updateOne(
        { sessionId: session.sessionId },
        { $set: { status: 'cancelled', endedAt: new Date() } }
      )
    );
    return true;
  } catch (error) {
    console.error('Error cancelling MCM session:', error);
    return false;
  }
}

// =======================================================================
// MCM ANNOUNCEMENTS AND REMINDERS
// =======================================================================

function formatReminderMessage(timeUntil) {
  const messages = [
    `üî• *MCM COUNTDOWN IS ON!* üî•\n\nLadies and gentlemen, welcome to the ultimate style showdown! üï∫‚ú®\n\nIn just ${timeUntil}, the spotlight turns on for MAN CRUSH MONDAY!\n\nüëë *Guys:* Prepare to impress with your sharpest photos ‚Äì the ladies are waiting to crown the king!\nüëÄ *Ladies:* Get your ratings ready ‚Äì 1 to 10, make it count!\n\nüí• Epic prizes: Winner grabs ‚Ç¶${mcmSettings.winnerReward.toLocaleString()} + bragging rights!\nüéâ Participation vibe: ‚Ç¶${mcmSettings.participationReward.toLocaleString()} just for joining the fun!\n\nTune in at 8:00 PM sharp ‚Äì this is YOUR stage! üì∫\n#MCMSpotlight #StyleNight #RateTheKings`,

    `üé§ *MCM IS STARTING SOON!* üé§\n\nThe clock is ticking... ${timeUntil} until the red carpet rolls out for MAN CRUSH MONDAY! üåü\n\nüëî *Guys, it's showtime:* Strike a pose, upload your killer pic, and let the ratings pour in!\nüíÉ *Ladies, you're the judges:* From 1-10, vote for the ultimate crush!\n\nüèÜ Grand prize alert: ‚Ç¶${mcmSettings.winnerReward.toLocaleString()} for the top gentleman!\nüéÅ Everyone wins: ‚Ç¶${mcmSettings.participationReward.toLocaleString()} for stepping into the arena!\n\nDon't miss the style, the charm, and the declarations at 8:00 PM! üì£\n#MCMLiveEvent #StyleShowdown #TuneInNow`
  ];
  
  return messages[Math.floor(Math.random() * messages.length)];
}

function formatMCMStartMessage() {
  return `üö® *BREAKING: MCM IS LIVE ON AIR!* üö®\n\nWelcome to the most stylish night of the week ‚Äì MAN CRUSH MONDAY! üì∫üí•\n\nü§µ *Gentlemen, take center stage:* Drop your best photo NOW and own the show!\nüë©‚Äç‚öñÔ∏è *Ladies, the power is yours:* Rate from 1-10 ‚Äì who will you crown?\n\n‚è≥ The clock is ticking until 10:00 PM ‚Äì make every second count!\nüí∞ Jackpot: Winner scores ‚Ç¶${mcmSettings.winnerReward.toLocaleString()}!\nüéâ Bonus: ‚Ç¶${mcmSettings.participationReward.toLocaleString()} for all stars who shine!\n\nüìú *Rules of the Game:*\n‚Ä¢ One photo per gent (duplicates? No spotlight!)\n‚Ä¢ Ratings 1-10 only ‚Äì keep it real!\n‚Ä¢ Self-rating: ${mcmSettings.allowSelfRating ? 'Go for it!' : 'Hands off your own!'}\n\nüí° *Pro Tip:* Use "8", "He's a 10", or emojis like üîü for ratings!\n\nLet the style, charm, and votes explode! üåü\n#MCMLive #GistHQShowdown #CrushHour`;
}

// =======================================================================
// ENHANCED RATING SYSTEM WITH EMOJI SUPPORT
// =======================================================================

function extractRating(text) {
  if (text.includes('1Ô∏è‚É£0Ô∏è‚É£')) return 10;
  
  const emojiToNumber = { 'üîü': 10, '9Ô∏è‚É£': 9, '8Ô∏è‚É£': 8, '7Ô∏è‚É£': 7, '6Ô∏è‚É£': 6, '5Ô∏è‚É£': 5, '4Ô∏è‚É£': 4, '3Ô∏è‚É£': 3, '2Ô∏è‚É£': 2, '1Ô∏è‚É£': 1 };
  
  for (const [emoji, number] of Object.entries(emojiToNumber).reverse()) {
    if (text.includes(emoji)) return number;
  }
  
  const numbers = text.match(/\b([1-9]|10)\b/g);
  if (!numbers) return null;
  
  const rating = parseInt(numbers[numbers.length - 1]);
  if (rating >= mcmSettings.validRatingRange.min && rating <= mcmSettings.validRatingRange.max) return rating;
  
  return null;
}

// =======================================================================
// NODE-CRON SCHEDULING SYSTEM
// =======================================================================

async function setupMCMCronJobs(sock) {
  try {
    stopAllCronJobs();
    
    mcmSettings.reminderTimes.forEach((reminderTime, index) => {
      const [hours, minutes] = reminderTime.split(':');
      const cronPattern = `${minutes} ${hours} * * 1`; // Monday
      
      const cronJob = cron.schedule(cronPattern, async () => {
        console.log(`‚è∞ MCM Reminder ${index + 1} triggered at ${reminderTime}`);
        await sendMCMReminders(sock);
      }, { scheduled: false, timezone: 'Africa/Lagos' });
      
      cronJobs.reminders.push(cronJob);
      cronJob.start();
      console.log(`‚úÖ MCM Reminder ${index + 1} scheduled`);
    });
    
    if (mcmSettings.autoStartEnabled) {
      const [startHours, startMinutes] = mcmSettings.startTime.split(':');
      const startCronPattern = `${startMinutes} ${startHours} * * 1`;
      
      cronJobs.startSession = cron.schedule(startCronPattern, async () => {
        console.log(`üé¨ MCM Auto-start at ${mcmSettings.startTime}`);
        for (const groupJid of mcmSettings.groupJids) {
          try {
            if (!await getCurrentSession(groupJid)) {
              await startMCMSession(sock, groupJid);
            }
          } catch (error) {
            console.error(`Error auto-starting for ${groupJid}:`, error);
          }
        }
      }, { scheduled: false, timezone: 'Africa/Lagos' });
      
      cronJobs.startSession.start();
      console.log(`‚úÖ MCM Auto-start scheduled`);
    }
    
    const [endHours, endMinutes] = mcmSettings.endTime.split(':');
    const endCronPattern = `${endMinutes} ${endHours} * * 1`;
    
    cronJobs.endSession = cron.schedule(endCronPattern, async () => {
      console.log(`üèÅ MCM Auto-end at ${mcmSettings.endTime}`);
      for (const groupJid of mcmSettings.groupJids) {
        try {
          await endMCMSession(sock, groupJid);
        } catch (error) {
          console.error(`Error auto-ending for ${groupJid}:`, error);
        }
      }
    }, { scheduled: false, timezone: 'Africa/Lagos' });
    
    cronJobs.endSession.start();
    console.log(`‚úÖ MCM Auto-end scheduled`);
    console.log('üéØ All MCM cron jobs setup');
    
  } catch (error) {
    console.error('Error setting up MCM cron jobs:', error);
  }
}

function stopAllCronJobs() {
  cronJobs.reminders.forEach(job => job && job.stop());
  cronJobs.reminders = [];
  if (cronJobs.startSession) { cronJobs.startSession.stop(); cronJobs.startSession = null; }
  if (cronJobs.endSession) { cronJobs.endSession.stop(); cronJobs.endSession = null; }
  console.log('üîÑ All MCM cron jobs stopped');
}

async function sendMCMReminders(sock) {
  try {
    if (!isMonday()) return;
    
    const startMoment = moment(`${getCurrentDate()} ${mcmSettings.startTime}`, 'YYYY-MM-DD HH:mm');
    const now = getNigeriaTime();
    
    if (now.isSameOrAfter(startMoment)) return;
    
    const timeUntil = moment.duration(startMoment.diff(now)).humanize();
    const reminderMessage = formatReminderMessage(timeUntil);
    
    for (const groupJid of mcmSettings.groupJids) {
      try {
        const members = await getGroupMembers(sock, groupJid);
        const mentions = mcmSettings.tagAllMembers ? members.map(m => m.id) : [];
        
        await sock.sendMessage(groupJid, { text: reminderMessage, mentions });
        console.log(`‚úÖ MCM reminder sent to ${groupJid}`);
      } catch (error) {
        console.error(`Error sending reminder to ${groupJid}:`, error);
      }
    }
  } catch (error) {
    console.error('Error sending reminders:', error);
  }
}

async function startMCMSession(sock, groupJid) {
  try {
    const session = await createMCMSession(groupJid);
    const startMessage = formatMCMStartMessage();
    
    const members = await getGroupMembers(sock, groupJid);
    const mentions = mcmSettings.tagAllMembers ? members.map(m => m.id) : [];
    
    const sentMessage = await sock.sendMessage(groupJid, { text: startMessage, mentions });
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).updateOne(
        { sessionId: session.sessionId },
        { $set: { startMessageKey: sentMessage.key } }
      )
    );
    
    console.log(`‚úÖ MCM session started for ${groupJid}`);
    return session;
  } catch (error) {
    console.error('Error starting MCM session:', error);
    throw error;
  }
}

// =======================================================================
// PHOTO SUBMISSION HANDLING
// =======================================================================

async function handlePhotoSubmission(m, sock) {
  try {
    if (!isMonday()) return false;
    
    const now = getNigeriaTime();
    const startMoment = moment(`${getCurrentDate()} ${mcmSettings.startTime}`, 'YYYY-MM-DD HH:mm');
    const endMoment = moment(`${getCurrentDate()} ${mcmSettings.endTime}`, 'YYYY-MM-DD HH:mm');
    
    if (now.isBefore(startMoment) || now.isSameOrAfter(endMoment)) return false;
    
    const senderId = m.key.participant || m.key.remoteJid;
    const groupJid = m.key.remoteJid;
    
    if (!groupJid.endsWith('@g.us') || !m.message.imageMessage) return false;
    
    const session = await getCurrentSession(groupJid);
    if (!session) return false;
    
    const existingParticipant = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_PARTICIPANTS).findOne({ sessionId: session.sessionId, userId: senderId })
    );
    
    if (existingParticipant) {
      await sock.sendMessage(groupJid, { react: { text: '‚ùå', key: m.key } });
      await sock.sendMessage(groupJid, {
        text: `üö´ @${senderId.split('@')[0]} - You already submitted your photo! Only your first photo counts for MCM.`,
        mentions: [senderId]
      }, { quoted: m });
      return true;
    }
    
    const participantData = {
      sessionId: session.sessionId,
      userId: senderId,
      userPhone: senderId.split('@')[0],
      messageKey: m.key,
      photoSubmittedAt: new Date(),
      ratings: [],
      totalRating: 0,
      averageRating: 0,
      ratingCount: 0
    };
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_PARTICIPANTS).insertOne(participantData)
    );
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_SESSIONS).updateOne(
        { sessionId: session.sessionId },
        { $push: { participants: senderId } }
      )
    );
    
    await sock.sendMessage(groupJid, { react: { text: '‚úÖ', key: m.key } });
    await unifiedUserManager.initUser(senderId); // Use unified user manager
    
    console.log(`üì∏ MCM photo submitted by ${senderId.split('@')[0]}`);
    return true;
    
  } catch (error) {
    console.error('Error handling photo submission:', error);
    return false;
  }
}

// =======================================================================
// RATING SUBMISSION HANDLING
// =======================================================================

async function handleRatingSubmission(m, sock) {
  try {
    if (!isMonday()) return false;
    
    const now = getNigeriaTime();
    const startMoment = moment(`${getCurrentDate()} ${mcmSettings.startTime}`, 'YYYY-MM-DD HH:mm');
    const endMoment = moment(`${getCurrentDate()} ${mcmSettings.endTime}`, 'YYYY-MM-DD HH:mm');
    
    if (now.isBefore(startMoment) || now.isSameOrAfter(endMoment)) return false;
    
    const senderId = m.key.participant || m.key.remoteJid;
    const groupJid = m.key.remoteJid;
    
    if (!groupJid.endsWith('@g.us') || !m.message.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) return false;
    
    const participantId = m.message.extendedTextMessage.contextInfo.participant;
    if (!participantId) return false;
    
    const session = await getCurrentSession(groupJid);
    if (!session) return false;
    
    const participant = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_PARTICIPANTS).findOne({ sessionId: session.sessionId, userId: participantId })
    );
    
    if (!participant) return false;
    
    if (!mcmSettings.allowSelfRating && senderId === participantId) {
      await sock.sendMessage(groupJid, { react: { text: 'üö´', key: m.key } });
      await sock.sendMessage(groupJid, {
        text: `üö´ @${senderId.split('@')[0]} - Self-rating is not allowed!`,
        mentions: [senderId]
      }, { quoted: m });
      return true;
    }
    
    const ratingText = m.body || '';
    const emojiToNumber = { 'üîü': 10, '9Ô∏è‚É£': 9, '8Ô∏è‚É£': 8, '7Ô∏è‚É£': 7, '6Ô∏è‚É£': 6, '5Ô∏è‚É£': 5, '4Ô∏è‚É£': 4, '3Ô∏è‚É£': 3, '2Ô∏è‚É£': 2, '1Ô∏è‚É£': 1 };
    const hasRatingAttempt = ratingText.match(/\b([1-9]|10)\b/) || Object.keys(emojiToNumber).some(emoji => ratingText.includes(emoji)) || ratingText.includes('1Ô∏è‚É£0Ô∏è‚É£');
    
    if (!hasRatingAttempt) return false;
    
    const rating = extractRating(ratingText);
    
    if (!rating) {
      await sock.sendMessage(groupJid, { react: { text: '‚ùå', key: m.key } });
      await sock.sendMessage(groupJid, {
        text: `‚ùå @${senderId.split('@')[0]} - Invalid rating! Please use a number or emoji between 1-10 (e.g., "8", "üîü").`,
        mentions: [senderId]
      }, { quoted: m });
      return true;
    }
    
    const existingRating = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_RATINGS).findOne({ sessionId: session.sessionId, raterId: senderId, participantId: participantId })
    );
    
    if (existingRating) {
      await safeOperation(async (db) => 
        await db.collection(COLLECTIONS.MCM_RATINGS).updateOne({ _id: existingRating._id }, { $set: { rating, updatedAt: new Date() } })
      );
    } else {
      const ratingData = { sessionId: session.sessionId, raterId: senderId, raterPhone: senderId.split('@')[0], participantId: participantId, participantPhone: participantId.split('@')[0], rating, createdAt: new Date() };
      await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RATINGS).insertOne(ratingData));
    }
    
    await updateParticipantRatings(session.sessionId, participantId);
    await sock.sendMessage(groupJid, { react: { text: '‚úÖ', key: m.key } });
    
    console.log(`‚≠ê MCM rating ${rating} by ${senderId.split('@')[0]} to ${participantId.split('@')[0]}`);
    return true;
    
  } catch (error) {
    console.error('Error handling rating:', error);
    return false;
  }
}

async function updateParticipantRatings(sessionId, participantId) {
  try {
    const ratings = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_RATINGS).find({ sessionId, participantId }).toArray()
    );
    
    const totalRating = ratings.reduce((sum, r) => sum + r.rating, 0);
    const ratingCount = ratings.length;
    const averageRating = ratingCount > 0 ? (totalRating / ratingCount) : 0;
    
    await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_PARTICIPANTS).updateOne(
        { sessionId, userId: participantId },
        { $set: { totalRating, averageRating: Math.round(averageRating * 100) / 100, ratingCount, updatedAt: new Date() } }
      )
    );
  } catch (error) {
    console.error('Error updating ratings:', error);
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// =======================================================================
// END MCM SESSION AND DECLARE WINNER
// =======================================================================

async function endMCMSession(sock, groupJid) {
  try {
    const session = await getCurrentSession(groupJid);
    if (!session) return false;
    
    const participants = await safeOperation(async (db) => 
      await db.collection(COLLECTIONS.MCM_PARTICIPANTS).find({ sessionId: session.sessionId })
        .sort({ totalRating: -1, ratingCount: -1 }).toArray()
    );
    
    if (participants.length === 0) {
      await sock.sendMessage(groupJid, { text: `üï∫ *MCM SESSION ENDED* üï∫\n\n‚ùå No participants today!\n\nBetter luck next Monday! üí™` });
      await safeOperation(async (db) => 
        await db.collection(COLLECTIONS.MCM_SESSIONS).updateOne({ sessionId: session.sessionId }, { $set: { status: 'ended', endedAt: new Date(), winnerDeclared: true } })
      );
      return true;
    }
    
    if (mcmSettings.enableParticipationReward) {
      for (const participant of participants) {
        await unifiedUserManager.addMoney(participant.userId, mcmSettings.participationReward, 'MCM participation');
      }
    }
    
    const maxTotal = participants[0].totalRating;
    const winners = participants.filter(p => p.totalRating === maxTotal);
    const hasValidRatings = winners.length > 0 && winners[0].ratingCount > 0;
    
    const members = await getGroupMembers(sock, groupJid);
    const mentions = mcmSettings.tagAllMembers ? members.map(m => m.id) : [];
    const participantMentions = participants.map(p => p.userId);
    
    await sock.sendMessage(groupJid, {
      text: `üé¨ *AND THAT'S A WRAP ON TONIGHT'S MCM!* üé¨\n\nLadies and gentlemen, what a thrilling show! The votes are in... now sit back as our judges tally the ratings!\n\nStay tuned ‚Äì results dropping in a moment! üìäüî•\n#MCMFinale #GistHQAfterShow`,
      mentions
    });
    
    await delay(60000);
    
    let resultsMessage = `üì£ *OFFICIAL MCM SCOREBOARD ‚Äì ${getCurrentDate()}* üì£\n\nFrom the Gist HQ studios, here are the final tallies for tonight's style showdown! üåü\n\nüìä *COMPLETE STANDINGS (Total Points):*\n\n`;
    participants.forEach((p, i) => {
      const pos = i + 1;
      const emoji = pos === 1 ? 'üëë' : pos === 2 ? 'ü•à' : pos === 3 ? 'ü•â' : 'üèÖ';
      const avg = p.averageRating > 0 ? p.averageRating.toFixed(1) : '0.0';
      resultsMessage += `${emoji} #${pos} @${p.userPhone}\n   ‚≠ê Total Points: ${p.totalRating} (${p.ratingCount} votes, avg ${avg}/10)\n\n`;
    });
    await sock.sendMessage(groupJid, { text: resultsMessage, mentions: participantMentions });
    
    await delay(5000);
    
    if (hasValidRatings) {
      let winnerMessage = `ü•Å *DRUMROLL PLEASE... THE MOMENT YOU'VE BEEN WAITING FOR!* ü•Å\n\nFrom the ratings, emerging victorious in tonight's MCM showdown...\n\n`;
      if (winners.length > 1) {
        winnerMessage += `üéâ *IT'S A TIE FOR THE CROWN!* üëë\n\nOur co-kings of the night:\n`;
        winners.forEach(w => { winnerMessage += `‚Ä¢ @${w.userPhone} with an epic ${w.totalRating} points! üåü\n`; });
        winnerMessage += `\nCongrats to our tied champions ‚Äì you rocked the stage! üï∫üî•\n\n`;
        await sock.sendMessage(groupJid, { text: winnerMessage, mentions: winners.map(w => w.userId) });
        for (const winner of winners) {
          await sock.sendMessage(groupJid, { text: `üëè Spotlight on our winner @${winner.userPhone}! Here's the photo that stole the show: üì∏`, mentions: [winner.userId] }, { quoted: { key: winner.messageKey, message: { imageMessage: {} } } });
          await delay(2000);
        }
      } else {
        const winner = winners[0];
        winnerMessage += `üëë *THE UNDISPUTED MCM CHAMPION: @${winner.userPhone} with ${winner.totalRating} points!* üëë\n\nWhat a performance! Congrats on your victory! üéäüí•\n\n`;
        await sock.sendMessage(groupJid, { text: winnerMessage, mentions: [winner.userId] });
        await sock.sendMessage(groupJid, { text: `üì∏ Relive the winning moment! Here's @${winner.userPhone}'s awesome entry: ‚ú®`, mentions: [winner.userId] }, { quoted: { key: winner.messageKey, message: { imageMessage: {} } } });
      }
      
      await delay(5000);
      
      const prizePerWinner = mcmSettings.winnerReward / winners.length;
      let rewardMessage = `üí∞ *PRIZE TIME FROM GIST HQ!* üí∞\n\n`;
      if (winners.length > 1) {
        rewardMessage += `Our tied winners each take home ‚Ç¶${prizePerWinner.toLocaleString()}! üèÜ\n\n`;
      } else {
        rewardMessage += `Our champion @${winners[0].userPhone} pockets ‚Ç¶${mcmSettings.winnerReward.toLocaleString()} ‚Äì enjoy it, king! ü§¥\n\n`;
      }
      rewardMessage += `Plus, shoutout to all participants for the ‚Ç¶${mcmSettings.participationReward.toLocaleString()} reward! üéÅ`;
      await sock.sendMessage(groupJid, { text: rewardMessage, mentions: winners.map(w => w.userId) });
    } else {
      await sock.sendMessage(groupJid, { text: `üòî *NO RATINGS TONIGHT ‚Äì THE CROWN STAYS VACANT!* üòî\n\nBetter luck next time, stars! No winner declared. üåü` });
    }
    
    await delay(60000);
    
    await sock.sendMessage(groupJid, {
      text: `üôå *THAT'S ALL FROM MCM TONIGHT!* üôå\n\nA massive thank you to all participants, raters, and everyone who tuned in! üéâ\n\nSame time next Monday at 8:00 PM ‚Äì get ready for more style and more crushes! Until then, keep shining! ‚ú®\n#MCMSignOff #SeeYouNextWeek #GistHQForever`,
      mentions
    });
    
    const recordData = {
      date: getCurrentDate(), groupJid, sessionId: session.sessionId, totalParticipants: participants.length,
      winners: hasValidRatings ? winners.map(w => ({ userId: w.userId, userPhone: w.userPhone, totalRating: w.totalRating, averageRating: w.averageRating, ratingCount: w.ratingCount, prizeAwarded: mcmSettings.winnerReward / winners.length })) : [],
      participants, createdAt: new Date()
    };
    
    await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RECORDS).insertOne(recordData));
    await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_SESSIONS).updateOne({ sessionId: session.sessionId }, { $set: { status: 'ended', endedAt: new Date(), winnerDeclared: true } }));
    
    console.log(`‚úÖ MCM session ended for ${groupJid}`);
    return true;
    
  } catch (error) {
    console.error('Error ending MCM session:', error);
    return false;
  }
}

// =======================================================================
// COMMAND HANDLERS
// =======================================================================

async function showMCMMenu(reply, prefix) {
  const nextMCM = moment().day(1).isBefore(moment()) ? moment().day(1).add(1, 'week').format('dddd, MMMM DD, YYYY') : moment().day(1).format('dddd, MMMM DD, YYYY');
  
  const menuText = `üï∫ *MAN CRUSH MONDAY (MCM)* üï∫\n\n` +
                  `üìä *User Commands:*\n` +
                  `‚Ä¢ *current* - View current MCM status\n` +
                  `‚Ä¢ *stats* - View your MCM statistics\n` +
                  `‚Ä¢ *history* - View MCM history\n` +
                  `‚Ä¢ *leaderboard* - View all-time winners\n\n` +
                  `üëë *Admin Commands:*\n` +
                  `‚Ä¢ *start* - Start MCM manually\n` +
                  `‚Ä¢ *end* - End current MCM\n` +
                  `‚Ä¢ *cancel* - Cancel current MCM\n` +
                  `‚Ä¢ *addgroup* - Add current group to MCM\n` +
                  `‚Ä¢ *removegroup* - Remove current group\n` +
                  `‚Ä¢ *addadmin <number>* - Add admin\n` +
                  `‚Ä¢ *removeadmin <number>* - Remove admin\n` +
                  `‚Ä¢ *settings* - System settings\n` +
                  `‚Ä¢ *reschedule* - Update cron schedules\n\n` +
                  `‚è∞ *Schedule (Node-Cron):*\n` +
                  `‚Ä¢ Every Monday 8:00 PM - 10:00 PM\n` +
                  `‚Ä¢ Reminders: 10:00 AM & 4:00 PM\n\n` +
                  `üí∞ *Rewards:*\n` +
                  `‚Ä¢ Winner: ‚Ç¶${mcmSettings.winnerReward.toLocaleString()}\n` +
                  `‚Ä¢ Participation: ‚Ç¶${mcmSettings.participationReward.toLocaleString()}\n\n` +
                  `üìÖ *Next MCM: ${nextMCM} 8:00 PM*\n\n` +
                  `üí° *Usage:* ${prefix}mcm [command]`;
  
  await reply(menuText);
}

async function handleMCMStart(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can start MCM.');
  if (!from.endsWith('@g.us')) return reply('‚ùå MCM in groups only.');
  try {
    if (await getCurrentSession(from)) return reply('üï∫ MCM already active!');
    await startMCMSession(sock, from);
    await reply('‚úÖ MCM started manually!');
  } catch (error) {
    await reply('‚ùå Error starting MCM.');
    console.error('MCM start error:', error);
  }
}

async function handleMCMEnd(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can end MCM.');
  if (!from.endsWith('@g.us')) return reply('‚ùå MCM in groups only.');
  try {
    const success = await endMCMSession(sock, from);
    if (success) return reply('‚úÖ MCM ended and results declared!');
    return reply('‚ùå No active MCM session.');
  } catch (error) {
    await reply('‚ùå Error ending MCM.');
    console.error('MCM end error:', error);
  }
}

async function handleMCMCancel(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can cancel MCM.');
  if (!from.endsWith('@g.us')) return reply('‚ùå MCM in groups only.');
  try {
    const success = await cancelMCMSession(from);
    if (success) {
      await sock.sendMessage(from, { text: '‚ùå MCM session cancelled!' });
      return reply('‚úÖ MCM cancelled.');
    }
    return reply('‚ùå No active MCM session.');
  } catch (error) {
    await reply('‚ùå Error cancelling MCM.');
    console.error('MCM cancel error:', error);
  }
}

async function handleMCMCurrent(context) {
  const { reply, from } = context;
  if (!from.endsWith('@g.us')) return reply('‚ùå MCM status in groups only.');
  try {
    const session = await getCurrentSession(from);
    if (!session) {
      const nextMCM = isMonday() ? `Today at ${mcmSettings.startTime}` : moment().day(1).add(1, 'week').format('dddd, MMMM DD') + ` at ${mcmSettings.startTime}`;
      return reply(`üìÖ *No active MCM*\n\nüï∫ *Next:* ${nextMCM}\nüí∞ *Winner:* ‚Ç¶${mcmSettings.winnerReward.toLocaleString()}`);
    }
    const participants = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_PARTICIPANTS).find({ sessionId: session.sessionId }).sort({ totalRating: -1, ratingCount: -1 }).toArray());
    const totalRatings = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RATINGS).countDocuments({ sessionId: session.sessionId }));
    let statusMessage = `üï∫ *MCM LIVE STATUS* üï∫\n\nüìÖ Date: ${session.date}\nüïê Started: ${moment(session.startedAt).format('HH:mm')}\n‚è∞ Ends: ${mcmSettings.endTime}\n\nüë• Participants: ${participants.length}\n‚≠ê Total Ratings: ${totalRatings}\n\n`;
    if (participants.length > 0) {
      statusMessage += `üìä *Current Standings (Total Points):*\n`;
      participants.slice(0, 5).forEach((p, i) => {
        const pos = i + 1;
        const emoji = pos === 1 ? 'üëë' : pos === 2 ? 'ü•à' : pos === 3 ? 'ü•â' : 'üèÖ';
        const avg = p.averageRating > 0 ? p.averageRating.toFixed(1) : '0.0';
        statusMessage += `${emoji} ${pos}. +${p.userPhone} - ${p.totalRating} pts (${p.ratingCount} ratings, avg ${avg})\n`;
      });
      if (participants.length > 5) statusMessage += `... and ${participants.length - 5} more\n`;
    } else {
      statusMessage += `‚ùå *No participants yet!*\n`;
    }
    statusMessage += `\nüí∞ *Winner gets ‚Ç¶${mcmSettings.winnerReward.toLocaleString()}!*`;
    await reply(statusMessage);
  } catch (error) {
    await reply('‚ùå Error loading status.');
    console.error('MCM current error:', error);
  }
}

async function handleMCMStats(context) {
  const { reply, senderId } = context;
  try {
    const stats = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RECORDS).aggregate([{ $unwind: '$participants' }, { $match: { 'participants.userId': senderId } }, { $group: { _id: null, participationCount: { $sum: 1 }, totalRatingsReceived: { $sum: '$participants.ratingCount' }, totalPoints: { $sum: '$participants.totalRating' }, bestRating: { $max: '$participants.averageRating' } } }]).toArray());
    const winStats = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RECORDS).aggregate([{ $unwind: '$winners' }, { $match: { 'winners.userId': senderId } }, { $group: { _id: null, winsCount: { $sum: 1 } } }]).toArray());
    const { participationCount = 0, totalRatingsReceived = 0, totalPoints = 0, bestRating = 0 } = stats[0] || {};
    const { winsCount = 0 } = winStats[0] || {};
    const averageRating = totalRatingsReceived > 0 ? (totalPoints / totalRatingsReceived).toFixed(1) : '0.0';
    const winRate = participationCount > 0 ? ((winsCount / participationCount) * 100).toFixed(1) : '0.0';
    const userData = await unifiedUserManager.getUserData(senderId);
    let statsMessage = `üìä *YOUR MCM STATISTICS* üìä\n\nüï∫ *Participation:*\n‚Ä¢ Total: ${participationCount}\n‚Ä¢ Wins: ${winsCount} üëë\n‚Ä¢ Win rate: ${winRate}%\n\n‚≠ê *Ratings:*\n‚Ä¢ Total received: ${totalRatingsReceived}\n‚Ä¢ Average: ${averageRating}/10\n‚Ä¢ Best: ${bestRating.toFixed(1)}/10\n\nüí∞ *Financial:*\n‚Ä¢ Balance: ‚Ç¶${(userData.balance || 0).toLocaleString()}\n‚Ä¢ MCM winnings: ‚Ç¶${(winsCount * mcmSettings.winnerReward).toLocaleString()}`;
    await reply(statsMessage);
  } catch (error) {
    await reply('‚ùå Error loading stats.');
    console.error('MCM stats error:', error);
  }
}

async function handleMCMHistory(context, args) {
  const { reply } = context;
  try {
    const limit = args[0] ? Math.min(parseInt(args[0]), 10) : 5;
    const records = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RECORDS).find({}).sort({ date: -1 }).limit(limit).toArray());
    if (records.length === 0) return reply('üìÖ *No MCM history.*');
    let historyMessage = `üìö *MCM HISTORY (Last ${records.length})* üìö\n\n`;
    records.forEach((record, i) => {
      historyMessage += `${i + 1}. üìÖ ${record.date}\n`;
      if (record.winners && record.winners.length > 0) {
        historyMessage += `   üëë Winners:\n`;
        record.winners.forEach(w => { historyMessage += `     ‚Ä¢ +${w.userPhone} (${w.totalRating} pts)\n`; });
        historyMessage += `   üí∞ Prize each: ‚Ç¶${record.winners[0].prizeAwarded.toLocaleString()}\n`;
      } else {
        historyMessage += `   ü§∑‚Äç‚ôÇÔ∏è No winner\n`;
      }
      historyMessage += `   üë• Participants: ${record.totalParticipants}\n\n`;
    });
    historyMessage += `üí° Use *mcm history [number]* for more`;
    await reply(historyMessage);
  } catch (error) {
    await reply('‚ùå Error loading history.');
    console.error('MCM history error:', error);
  }
}

async function handleMCMLeaderboard(context) {
  const { reply } = context;
  try {
    const leaders = await safeOperation(async (db) => await db.collection(COLLECTIONS.MCM_RECORDS).aggregate([{ $unwind: '$winners' }, { $group: { _id: '$winners.userId', userPhone: { $first: '$winners.userPhone' }, wins: { $sum: 1 }, totalEarnings: { $sum: '$winners.prizeAwarded' }, bestRating: { $max: '$winners.averageRating' }, totalRatings: { $sum: '$winners.ratingCount' } } }, { $sort: { wins: -1, bestRating: -1 } }, { $limit: 10 }]).toArray());
    if (leaders.length === 0) return reply('üèÜ *No MCM winners yet!*\n\nBe the first! üí™');
    let leaderboardMessage = `üèÜ *MCM HALL OF FAME* üèÜ\n\nüëë *ALL-TIME LEADERBOARD:*\n\n`;
    leaders.forEach((leader, i) => {
      const pos = i + 1;
      const emoji = pos === 1 ? 'üëë' : pos === 2 ? 'ü•à' : pos === 3 ? 'ü•â' : 'üèÖ';
      leaderboardMessage += `${emoji} ${pos}. +${leader.userPhone}\n   üèÜ Wins: ${leader.wins}\n   ‚≠ê Best: ${leader.bestRating.toFixed(1)}/10\n   üí∞ Earned: ‚Ç¶${leader.totalEarnings.toLocaleString()}\n\n`;
    });
    leaderboardMessage += `üï∫ *Can you top the leaderboard?*\nNext MCM: Every Monday 8:00 PM!`;
    await reply(leaderboardMessage);
  } catch (error) {
    await reply('‚ùå Error loading leaderboard.');
    console.error('MCM leaderboard error:', error);
  }
}

async function handleMCMSettings(context, args) {
  const { reply, senderId, sock, from, config } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can access settings.');
  try {
    if (args.length === 0) {
      let settingsMessage = `‚öôÔ∏è *MCM SETTINGS* ‚öôÔ∏è\n\n` +
        `üïê *Schedule:*\n‚Ä¢ Start: ${mcmSettings.startTime}\n‚Ä¢ End: ${mcmSettings.endTime}\n‚Ä¢ Auto-start: ${mcmSettings.autoStartEnabled ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Reminders: ${mcmSettings.reminderTimes.join(', ')}\n\n` +
        `üí∞ *Rewards:*\n‚Ä¢ Winner: ‚Ç¶${mcmSettings.winnerReward.toLocaleString()}\n‚Ä¢ Participation: ‚Ç¶${mcmSettings.participationReward.toLocaleString()}\n‚Ä¢ Participation: ${mcmSettings.enableParticipationReward ? '‚úÖ' : '‚ùå'}\n\n` +
        `üîß *Other:*\n‚Ä¢ Self-rating: ${mcmSettings.allowSelfRating ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Tag all: ${mcmSettings.tagAllMembers ? '‚úÖ' : '‚ùå'}\n\n` +
        `üîß *Commands:*\n‚Ä¢ \`${config.PREFIX}mcm settings prize 15000\`\n‚Ä¢ \`${config.PREFIX}mcm settings participation 1500\`\n‚Ä¢ \`${config.PREFIX}mcm settings starttime 20:30\`\n‚Ä¢ \`${config.PREFIX}mcm settings endtime 22:30\`\n‚Ä¢ \`${config.PREFIX}mcm settings autostart on/off\`\n` +
        `‚Ä¢ \`${config.PREFIX}mcm settings parreward on/off\`\n‚Ä¢ \`${config.PREFIX}mcm settings selfrating on/off\`\n‚Ä¢ \`${config.PREFIX}mcm settings tagall on/off\``;
      await reply(settingsMessage);
      return;
    }
    const setting = args[0].toLowerCase();
    const value = args[1]?.toLowerCase();
    let responseText = "";
    let needsReschedule = false;
    switch (setting) {
      case 'prize': case 'winner':
        const prize = parseInt(args[1]);
        if (isNaN(prize)) return reply(`‚ö†Ô∏è Invalid. Use: ${config.PREFIX}mcm settings prize 15000`);
        mcmSettings.winnerReward = prize;
        responseText = `‚úÖ Winner prize: ‚Ç¶${prize.toLocaleString()}`;
        break;
      case 'participation':
        const part = parseInt(args[1]);
        if (isNaN(part)) return reply(`‚ö†Ô∏è Invalid. Use: ${config.PREFIX}mcm settings participation 1500`);
        mcmSettings.participationReward = part;
        responseText = `‚úÖ Participation: ‚Ç¶${part.toLocaleString()}`;
        break;
      case 'starttime':
        if (!/^\d{2}:\d{2}$/.test(args[1])) return reply(`‚ö†Ô∏è Invalid. Use: ${config.PREFIX}mcm settings starttime 20:30`);
        mcmSettings.startTime = args[1];
        needsReschedule = true;
        responseText = `‚úÖ Start time: ${args[1]}. Rescheduling cron.`;
        break;
      case 'endtime':
        if (!/^\d{2}:\d{2}$/.test(args[1])) return reply(`‚ö†Ô∏è Invalid. Use: ${config.PREFIX}mcm settings endtime 22:30`);
        mcmSettings.endTime = args[1];
        needsReschedule = true;
        responseText = `‚úÖ End time: ${args[1]}. Rescheduling cron.`;
        break;
      case 'autostart': case 'parreward': case 'selfrating': case 'tagall':
        const flag = ['on', 'true', 'enable'].includes(value);
        const keyMap = { autostart: 'autoStartEnabled', parreward: 'enableParticipationReward', selfrating: 'allowSelfRating', tagall: 'tagAllMembers' };
        const settingKey = keyMap[setting];
        if (settingKey) {
            mcmSettings[settingKey] = flag;
            responseText = `‚úÖ ${setting} ${flag ? 'enabled' : 'disabled'}.`;
            if (setting === 'autostart') needsReschedule = true;
        } else {
            responseText = `‚ö†Ô∏è Use: on/off`;
        }
        break;
      default:
        responseText = `‚ö†Ô∏è Unknown: ${setting}\nAvailable: prize, participation, starttime, endtime, autostart, parreward, selfrating, tagall`;
    }
    await saveSettings();
    await reply(responseText);
    if (needsReschedule && context.sock) setupMCMCronJobs(context.sock);
  } catch (error) {
    await reply('‚ùå Error updating settings.');
    console.error('MCM settings error:', error);
  }
}

async function handleMCMReschedule(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can reschedule.');
  try {
    await setupMCMCronJobs(sock);
    await reply('‚úÖ Cron jobs rescheduled!');
  } catch (error) {
    await reply('‚ùå Error rescheduling.');
    console.error('MCM reschedule error:', error);
  }
}

async function handleMCMAddGroup(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can add groups.');
  if (!from.endsWith('@g.us')) return reply('‚ùå Use in group.');
  if (mcmSettings.groupJids.includes(from)) return reply('‚úÖ Group already added.');
  mcmSettings.groupJids.push(from);
  await saveSettings();
  await reply('‚úÖ Group added to MCM!');
}

async function handleMCMRemoveGroup(context) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can remove groups.');
  if (!from.endsWith('@g.us')) return reply('‚ùå Use in group.');
  const index = mcmSettings.groupJids.indexOf(from);
  if (index === -1) return reply('‚ùå Group not in MCM.');
  mcmSettings.groupJids.splice(index, 1);
  await saveSettings();
  await reply('‚úÖ Group removed from MCM.');
}

async function handleMCMAddAdmin(context, args) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can add admins.');
  const number = args[0]?.replace(/\D/g, '');
  if (!number) return reply('‚ö†Ô∏è Use: addadmin <number>');
  if (mcmSettings.adminNumbers.includes(number)) return reply('‚úÖ Already admin.');
  mcmSettings.adminNumbers.push(number);
  await saveSettings();
  await reply(`‚úÖ Admin added: ${number}`);
}

async function handleMCMRemoveAdmin(context, args) {
  const { reply, senderId, sock, from } = context;
  if (!await isAuthorized(sock, from, senderId)) return reply('üö´ Only admins can remove admins.');
  const number = args[0]?.replace(/\D/g, '');
  if (!number) return reply('‚ö†Ô∏è Use: removeadmin <number>');
  const index = mcmSettings.adminNumbers.indexOf(number);
  if (index === -1) return reply('‚ùå Not an admin.');
  mcmSettings.adminNumbers.splice(index, 1);
  await saveSettings();
  await reply(`‚úÖ Admin removed: ${number}`);
}

async function handleMCMTest(context, args) {
  const { reply, config } = context;
  const testText = args.join(' ');
  if (!testText) return reply(`üîç *MCM RATING VALIDATOR* üîç\n\n*Usage:* ${config.PREFIX}mcmtest [message]\n\n*Examples:*\n‚Ä¢ ${config.PREFIX}mcmtest "He looks great! 9"\n‚Ä¢ ${config.PREFIX}mcmtest "8Ô∏è‚É£ handsome"\n‚Ä¢ ${config.PREFIX}mcmtest "üîü amazing star!"`);
  try {
    const rating = extractRating(testText);
    let result = `üîç *RESULTS* üîç\n\nüìù Message: "${testText}"\n\n`;
    if (rating) {
      result += `‚úÖ *VALID!*\n‚≠ê Rating: ${rating}/10\n`;
    } else {
      result += `‚ùå *INVALID*\n\nüí° *Formats:*\n‚Ä¢ Numbers: "9", "10", "He's a perfect 8"\n‚Ä¢ Emojis: "9Ô∏è‚É£", "üîü", "Awesome 1Ô∏è‚É£0Ô∏è‚É£"\n‚Ä¢ Range: 1-10`;
    }
    await reply(result);
  } catch (error) {
    await reply('‚ùå Error testing.');
    console.error('MCM test error:', error);
  }
}

// =======================================================================
// MAIN PLUGIN HANDLER AND INIT
// =======================================================================

export async function init(sock) {
  await loadSettings();
  await setupMCMCronJobs(sock);
  console.log('‚úÖ MCM plugin initialized');
}

export default async function mcmHandler(m, sock, config) {
  try {
    if (m.body && !m.body.startsWith(config.PREFIX)) {
      if (await handlePhotoSubmission(m, sock)) return;
      if (await handleRatingSubmission(m, sock)) return;
    }
    
    if (!m.body || !m.body.startsWith(config.PREFIX)) return;
    
    const args = m.body.slice(config.PREFIX.length).trim().split(' ');
    const command = args.shift().toLowerCase();
    const senderId = m.key.participant || m.key.remoteJid;
    const from = m.key.remoteJid;
    const reply = async (text) => sock.sendMessage(from, { text }, { quoted: m });
    
    if (['mcm', 'mancrush'].includes(command)) {
      if (args.length === 0) return await showMCMMenu(reply, config.PREFIX);
      await handleMCMSubCommand(args[0], args.slice(1), { m, sock, config, senderId, from, reply });
    } else if (['mcmstats', 'mcmhistory'].includes(command)) {
      await handleMCMStats({ senderId, reply });
    } else if (['mcmtest', 'testmcm'].includes(command)) {
      await handleMCMTest({ reply, config }, args);
    }
    
  } catch (error) {
    console.error('‚ùå MCM plugin error:', error);
  }
}

async function handleMCMSubCommand(subCommand, args, context) {
  switch (subCommand.toLowerCase()) {
    case 'start': await handleMCMStart(context); break;
    case 'end': await handleMCMEnd(context); break;
    case 'cancel': await handleMCMCancel(context); break;
    case 'current': case 'status': await handleMCMCurrent(context); break;
    case 'stats': await handleMCMStats(context); break;
    case 'history': await handleMCMHistory(context, args); break;
    case 'leaderboard': case 'leaders': await handleMCMLeaderboard(context); break;
    case 'settings': await handleMCMSettings(context, args); break;
    case 'reschedule': await handleMCMReschedule(context); break;
    case 'addgroup': await handleMCMAddGroup(context); break;
    case 'removegroup': await handleMCMRemoveGroup(context); break;
    case 'addadmin': await handleMCMAddAdmin(context, args); break;
    case 'removeadmin': await handleMCMRemoveAdmin(context, args); break;
    case 'test': await handleMCMTest(context, args); break;
    case 'help': await showMCMMenu(context.reply, context.config.PREFIX); break;
    default: await context.reply(`‚ùì Unknown: *${subCommand}*\n\nUse *${context.config.PREFIX}mcm help*`);
  }
}

export { 
  setupMCMCronJobs,
  stopAllCronJobs,
  mcmSettings
};
